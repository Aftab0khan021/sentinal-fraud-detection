input {
  # Collect logs from Docker containers
  tcp {
    port => 5000
    codec => json
  }
  
  # Collect logs from files
  file {
    path => "/var/log/sentinal/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => json
  }
  
  # Collect logs from Filebeat (if used)
  beats {
    port => 5044
  }
}

filter {
  # Parse JSON logs
  if [message] =~ /^\{/ {
    json {
      source => "message"
    }
  }
  
  # Add common fields
  mutate {
    add_field => {
      "[@metadata][index_prefix]" => "sentinal"
    }
  }
  
  # Parse timestamp
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
    }
  }
  
  # Extract log level
  if [level] {
    mutate {
      uppercase => [ "level" ]
    }
  }
  
  # Parse API logs
  if [logger] == "api" {
    grok {
      match => {
        "message" => "%{WORD:method} %{URIPATH:path} %{NUMBER:status_code:int} %{NUMBER:response_time:float}ms"
      }
      tag_on_failure => ["_grokparsefailure_api"]
    }
  }
  
  # Parse NGINX logs
  if [source] == "nginx" {
    grok {
      match => {
        "message" => '%{IPORHOST:client_ip} - - \[%{HTTPDATE:timestamp}\] "%{WORD:method} %{URIPATH:path} HTTP/%{NUMBER:http_version}" %{NUMBER:status_code:int} %{NUMBER:bytes:int} "%{DATA:referrer}" "%{DATA:user_agent}"'
      }
      tag_on_failure => ["_grokparsefailure_nginx"]
    }
    
    # Parse timestamp
    if [timestamp] {
      date {
        match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
        target => "@timestamp"
      }
    }
  }
  
  # GeoIP lookup for client IPs
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
  
  # Extract trace ID for correlation
  if [trace_id] {
    mutate {
      add_field => { "trace_id_short" => "%{trace_id}" }
    }
    mutate {
      gsub => [ "trace_id_short", "^(.{8}).*", "\1" ]
    }
  }
  
  # Classify log severity
  if [level] == "ERROR" or [level] == "CRITICAL" {
    mutate {
      add_tag => [ "error" ]
    }
  } else if [level] == "WARNING" or [level] == "WARN" {
    mutate {
      add_tag => [ "warning" ]
    }
  }
  
  # Detect security events
  if [message] =~ /authentication failed|unauthorized|forbidden|brute force/ {
    mutate {
      add_tag => [ "security" ]
    }
  }
  
  # Detect fraud events
  if [message] =~ /fraud detected|high risk|suspicious/ {
    mutate {
      add_tag => [ "fraud" ]
    }
  }
  
  # Remove unnecessary fields
  mutate {
    remove_field => [ "host", "agent", "ecs" ]
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "%{[@metadata][index_prefix]}-%{+YYYY.MM.dd}"
    
    # Template for index mapping
    template_name => "sentinal"
    template_overwrite => true
  }
  
  # Output to stdout for debugging (disable in production)
  # stdout {
  #   codec => rubydebug
  # }
  
  # Output errors to separate index
  if "error" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "sentinal-errors-%{+YYYY.MM.dd}"
    }
  }
  
  # Output security events to separate index
  if "security" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "sentinal-security-%{+YYYY.MM.dd}"
    }
  }
}
